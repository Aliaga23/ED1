//---------------------------------------------------------------------------

#pragma hdrstop

#include "EjemplosCod.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
                                         //	menuLS();
	/*cout << "1.Conjunto Sm\n";
	 cout << "2.Conjunto Ptr\n";
	 cout << "3.Conjunto Vector\n";
	 cout << "4.Conjunto Listas\n";

	 cout << "Opcion : ";
	 int op;
	 cin >> op;
	 if (op == 1) {
	 CsMemoria *m;
	 ConjuntoSm* a;
	 ConjuntoSm* b;
	 ConjuntoSm* c;
	 MenuSm(m, a, b, c);
	 }
	  if (op == 2) {
	 ConjuntoPtr* a;
	 ConjuntoPtr* b;
	 ConjuntoPtr* c;
	 MenuPtr(a, b, c);
	 }
 if (op == 3) {
	 ConjuntoV* a;
	 ConjuntoV* b;
	 ConjuntoV* c;
	 MenuVector(a, b, c);
	 }
	  if (op == 4) {
	ConjuntoListaPtr* a;
	 ConjuntoListaPtr* b;
	 ConjuntoListaPtr* c;
	 MenuListaPtr(a, b, c);
	 }
	  */
    // menuPoliPun();
    /*PoliP* fx;
	   fx = new PoliP();
	   fx->poner_termino(5, 2);

	   fx->poner_termino(4, 3);

	   fx->poner_termino(3, 1);
	   cout << fx->to_str() << endl;

	system("pause");
	*/
    //menuS();
    /*
	ConjuntoPtr A;
	ConjuntoPtr B;
	ConjuntoPtr C;

	int opcion;

	do {
		cout << "1. Insertar valor en A\n";
		cout << "2. Insertar valor en B\n";
		cout << "3. Realizar intersección y mostrar C\n";
		cout << "4. Mostrar C\n";
		cout << "Salir\n";

		cout << "Opcion: ";
		cin >> opcion;

		switch (opcion) {
			case 1: {
				int valorA;
				cout << "Ingrese valor para A: ";
				cin >> valorA;
				A.inserta(valorA);
			} break;
			case 2: {
				int valorB;
				cout << "Ingrese valor para B: ";
				cin >> valorB;
				B.inserta(valorB);
			} break;
			case 3: {
				//intersectarConjuntos(&A, &B, C);
				A.inserta(1);
				A.inserta(2);
				A.inserta(3);
				A.inserta(4);
				B.inserta(1);
				B.inserta(5);
				B.inserta(3);
				B.inserta(85);

				complementoInterseccion(&A, &B, C);
				cout << C.to_str() << endl;
			} break;
		}
		system("pause");
		system("cls");
	} while (opcion != 4);
	*/

	//  MatrizV matriz;

	// Dimensiona la matriz con 4 filas y 4 columnas
	//matriz.dimensionar(4, 4);

	// Ingresa algunos datos en la matriz
	//    matriz.poner(1, 1, 0);
	//	matriz.poner(1, 2, 0);
	//	matriz.poner(1, 3, 0);
	//	matriz.poner(1, 4, 11);
	//	matriz.poner(3, 1, 0);
	//	matriz.poner(3, 2, 50);
	//	matriz.poner(3, 3, 85);
	//	matriz.poner(3, 4, 2581);
	//
	//	matriz.poner(4, 1, 7);
	//	matriz.poner(4, 2, 0);
	//	//matriz.poner(4, 3, 2);
	//	matriz.poner(4, 4, 0);
	//	matriz.definir_valor_repetido(59);
	//	string repre;
	//	repre=matriz.to_str();
	//	cout<<repre;
	//---------------------------------------------
	//    CsMemoria* memoria;
	//	MatrizSM* matriz;
	//	memoria = new CsMemoria();
	//	matriz = new MatrizSM(memoria);
    //	////	// Definir el valor repetido
    //	matriz->definir_valor_repetido(15);
    //	////
    //	////	// Dimensionar la matriz 3x3
	//	matriz->dimensionar(3, 3);
    //	matriz->poner(1, 2, 500);
    //	if (esSimetrica(*matriz)) {
    //		cout << "La matriz es simetrica." << endl;
    //	} else {
    //		cout << "La matriz no es simetrica." << endl;
    //	}
    //	matriz->dimensionar(4, 3);
	////
    ////	// Llenar la matriz con datos
    //	matriz->poner(2, 2, 500);
    ////	//matriz->poner(1, 2, 1500);
    ////
    ////
    //	cout << "Matriz:\n" << matriz->to_str() << endl;
    //	matriz->transponer();
    //	//matriz->definir_valor_repetido(15);
	////	// Mostrar la matriz
    //	cout << "Matriz:\n" << matriz->to_str() << endl;
    //
    //
    //	//cout << "Matriz:\n" << matriz->to_str() << endl;
    //	// Mostrar la memoria
    //   //	memoria->mostrar();
    //--------------------------------------------------------------------
    //MatrizPC matriz;
	//MatrizPC* matriz;
    //matriz = new MatrizPC();
    //matriz->definir_valor_repetido(15);
    //matriz->dimensionar(4, 3);
    //
    //			 cout << "Matriz:\n" << matriz->to_str() << endl;
    //			 matriz->transponer();
    //			 matriz->definir_valor_repetido(15);
    //			 matriz->poner(1, 2, 1500);
	//			  cout << "Matriz:\n" << matriz->to_str() << endl;
    //
	//    ListaP lista;
	//
	//    // Agregar elementos a la lista
	//   //lista.inserta_primero(15);
	//  //	lista.inserta_primero(15);
	//	lista.inserta_primero(10);
	//	lista.inserta_primero(15);
	//	lista.inserta_ultimo(2);
	//    lista.inserta_ultimo(2);
	//	lista.inserta_ultimo(15);
	//    lista.inserta_ultimo(15);
	//	lista.ordenarAscendente();
	//	cout << "Lista original: " << lista.to_str() <<endl;
	//	lista.eliminarRepetidos();
	//	// Llamar al método para eliminar el elemento más grande
	//   // lista.eliminarMayor();
	//    cout << "Lista original: " << lista.to_str() <<endl;

	//std::cout << "Lista después de eliminar el elemento más grande: "
	//        << lista.to_str() << std::endl;





    /*
void menu()
{
	CsMemoria* mem;
	int opcion;
	do {
		cout << "1.Crear" << endl;
		cout << "2.Pedir espacio" << endl;
		cout << "3.Liberar espacio" << endl;
		cout << "4.Poner dato" << endl;
		cout << "5.Mostrar Memoria" << endl;
		cout << "6.Salir" << endl;
		cout << "Opcion: ";
		cin >> opcion;
		switch (opcion) {
			case 1: {
				mem = new CsMemoria();
				cout << "Memoria Creada\n";
			} break;
			case 2: {
				string ids;
				cout << "Ids: ";
				cin.ignore();
				getline(cin, ids);
				mem->new_espacio(ids);
			} break;
			case 3: {
				int dir_delete;
				cout << "Direccion a liberar: ";
				cin >> dir_delete;
				mem->delete_espacio(dir_delete);
			} break;
			case 4: {
				int dir, valor;
				string id;
				cout << "Direccion: " << endl;
				cin >> dir;
				cout << "Id: " << endl;
				cin.ignore();
				getline(cin, id);
				cout << "Valor: " << endl;
				cin >> valor;
				mem->poner_dato(dir, id, valor);
			} break;
			case 5: {
				mem->mostrar();
			} break;
		}
		system("pause");
		system("cls");
	} while (opcion != 6);
}
		*/









